|时间|出处|句子|理解|
| :----------: | :--- | :--- | :--- |
|2019年2月2日 10:13:51|《敏捷软件开发：原则、模式与实践》——第六章|一最简单的方法编写该模块。仅当需求最终却是变化时，才修改模块的设计，使模块对该种变化具有弹性|在必要时候将需求**抽象**，来兼容未来的需求。在不修改**业务逻辑**的情况下，添加实体类既是一个良好的抽象
||`SRP`：单一职责原则
|||| + 过多的耦合会导致脆弱的设计！<br /> + 如果你能够想到多于一个动机去修改一个类，那么这个类就不符合`SRP`原则<br /> + 并不是所有的设计都需要遵守`SRP`原则，不必要的`SRP`将导致不必要的复杂性<br /> ++ 当`A`变化导致`B`不得不变时，则需要考虑`SRP`原则。当`AB`一起变化时则不需要考虑`SRP`原则<br />|
|||解耦的职责|模块之间不存在污染，既是函数的`SRP`原则
|2019年2月3日 13:11:03|`OCP`：开放封闭原则|模块依赖于固定的抽象体，所以`更改是封闭的；通过实现派生类，扩展`此模块行为|即对扩展开放，对修改封闭。通过抽象类封装接口，通过派生类完成具体实现。<br />**`PS：该原理仅适用于业务流程不变的情况`**
|||抽象类与客户的关系比与实现者的关系更密切
|||实际上新增模块必须修改系统中的某一部分，但遵循`OCP`原则设计的程序无需修改不相关的部分。并且不依赖新增模块的程序无需修改相关的二进制文件`(.dll)`文件|只有一个例外，就是实际创建抽象模型实体对象的模块被改动。通常是Main或者被Main调用的对象或函数<br />换言之当增加一个新模块时只需要`实现该模块并修改创建该模块的模块`时，即遵循了`OCP`原则（并不是一定要修改创建模块的模块代表）
|||`OCP`代价相当昂贵。通常，我们一直等到变化发生时再采取行动|没有对所有情况都贴切的模型
|||拒绝不成熟的抽象与抽象本身同样重要
|2019年3月6日 12:40:16|`Liskov`替换原则|子类型必须能够替换掉他们的基类型