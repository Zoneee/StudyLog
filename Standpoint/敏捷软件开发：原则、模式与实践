> 敏捷软件开发：原则、模式与实践

|时间|出处|句子|理解|
| :----------: | :--- | :--- | :--- |
|2019年2月2日 10:13:51|`SRP`：单一职责原则|最简单的方法编写该模块。仅当需求最终却是变化时，才修改模块的设计，使模块对该种变化具有弹性|在必要时候将需求**抽象**，来兼容未来的需求。在不修改**业务逻辑**的情况下，添加实体类既是一个良好的抽象
|||| + 过多的耦合会导致脆弱的设计！<br /> + 如果你能够想到多于一个动机去修改一个类，那么这个类就不符合`SRP`原则<br /> + 并不是所有的设计都需要遵守`SRP`原则，不必要的`SRP`将导致不必要的复杂性<br /> ++ 当`A`变化导致`B`不得不变时，则需要考虑`SRP`原则。当`AB`一起变化时则不需要考虑`SRP`原则<br />|
|||解耦的职责|模块之间不存在污染，既是函数的`SRP`原则
|2019年2月3日 13:11:03|`OCP`：开放封闭原则|模块依赖于固定的抽象体，所以`更改是封闭的；通过实现派生类，扩展`此模块行为|即对扩展开放，对修改封闭。通过抽象类封装接口，通过派生类完成具体实现。<br />**`PS：该原理仅适用于业务流程不变的情况`**
|||抽象类与客户的关系比与实现者的关系更密切
|||实际上新增模块必须修改系统中的某一部分，但遵循`OCP`原则设计的程序无需修改不相关的部分。并且不依赖新增模块的程序无需修改相关的二进制文件`(.dll)`文件|只有一个例外，就是实际创建抽象模型实体对象的模块被改动。通常是Main或者被Main调用的对象或函数<br />换言之当增加一个新模块时只需要`实现该模块并修改创建该模块的模块`时，即遵循了`OCP`原则（并不是一定要修改创建模块的模块代表）
|||`OCP`代价相当昂贵。通常，我们一直等到变化发生时再采取行动|没有对所有情况都贴切的模型<br />拒绝不成熟的抽象与抽象本身同样重要
|2019年3月6日 12:40:16|`LSP`：Liskov替换原则|子类型必须能够替换掉他们的基类型|实际上只要子类型与基类型产生的结果有差异就不符合`LSP`。需要在实现正义与原则正义中做权衡
|||违反`LSP`时通常也会违反`OCP`
|||一个模型，如果孤立的看，并不具有真正意义上的的有效性。模型的有效性只能通过它的客户程序来表现|只预测那些最明显违反`LSP`的情况，其他的等到遇到再处理，过多的预测会导致过于复杂的程序
|||完成功能少于其基类的派生类通常是不能替换基类的|当某个基类的派生类，以某种方式将基类中的函数`退化`。例如：派生类中抛出了基类没有的异常、派生类通过`override、new`等方式退化了基类，那么这个基类就不能替换基类，但并不一定不满足`LSP`
|2019年3月8日 10:06:04|`DIP`：依赖倒置原则|1、高层模块不应依赖底层模块，二者都应依赖于抽象<br />2、抽象不应依赖于细节，细节应依赖于抽象|当程序表现出**高层依赖于底层**时，这些看起来正确的依赖关系可能隐藏了错误特征`依赖关系是传递的`。当底层做出修改时，高层将不得不修改。或高层需要频繁修改时底层不得不做出相关适配。<br />更为适合的方式是将两者**依赖关系倒置**，`底层依赖（实现）高层的抽象`。这样就解除了`依赖传递关系`，高层的所有改变被隐藏在`抽象`中，底层的所有改变只需要遵循高层的`抽象`即可。
|||通常是客户端拥有抽象，服务端从抽象派生
|||Don't call us. We'll call you
|||1、任何变量都不应该指向具体类的引用<br />2、任何类都不应从具体类派生<br />3、任何派生类都不应重写基类已经实现的函数|抽象的目的是不依赖于不稳定的类
|2019年3月12日 12:39:58|`ISP`：接口隔离原则|不应该强迫客户程序依赖并未使用的方法|减少接口污染
|||分离客户即是分离接口
|||接口必须接受必要的修复Bug的改动
|||使用委托分离接口
